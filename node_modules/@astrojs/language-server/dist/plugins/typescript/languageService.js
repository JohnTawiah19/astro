"use strict";
/* eslint-disable require-jsdoc */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLanguageServiceForPath = exports.getLanguageServiceForDocument = exports.getLanguageService = void 0;
const ts = __importStar(require("typescript"));
const path_1 = require("path");
const utils_1 = require("./utils");
const SnapshotManager_1 = require("./SnapshotManager");
const DocumentSnapshot_1 = require("./DocumentSnapshot");
const module_loader_1 = require("./module-loader");
const services = new Map();
async function getLanguageService(path, workspaceUris, docContext) {
    const tsconfigPath = (0, utils_1.findTsConfigPath)(path, workspaceUris);
    const workspaceRoot = docContext.getWorkspaceRoot(path);
    let service;
    if (services.has(tsconfigPath)) {
        service = (await services.get(tsconfigPath));
    }
    else {
        const newServicePromise = createLanguageService(tsconfigPath, workspaceRoot, docContext);
        services.set(tsconfigPath, newServicePromise);
        service = await newServicePromise;
    }
    return service;
}
exports.getLanguageService = getLanguageService;
async function getLanguageServiceForDocument(document, workspaceUris, docContext) {
    return getLanguageServiceForPath(document.getFilePath() || '', workspaceUris, docContext);
}
exports.getLanguageServiceForDocument = getLanguageServiceForDocument;
async function getLanguageServiceForPath(path, workspaceUris, docContext) {
    return (await getLanguageService(path, workspaceUris, docContext)).getService();
}
exports.getLanguageServiceForPath = getLanguageServiceForPath;
async function createLanguageService(tsconfigPath, workspaceRoot, docContext) {
    var _a, _b, _c;
    const parseConfigHost = {
        ...ts.sys,
        readDirectory: (path, extensions, exclude, include, depth) => {
            return ts.sys.readDirectory(path, [...extensions, '.vue', '.svelte', '.astro', '.js', '.jsx'], exclude, include, depth);
        },
    };
    let configJson = (tsconfigPath && ts.readConfigFile(tsconfigPath, ts.sys.readFile).config) || {};
    // If our user has types in their config but it doesn't include the types for ImportMeta, let's add them for them
    if (((_a = configJson.compilerOptions) === null || _a === void 0 ? void 0 : _a.types) &&
        !((_b = configJson.compilerOptions) === null || _b === void 0 ? void 0 : _b.types.includes("vite/client"))) {
        configJson.compilerOptions.types.push("vite/client");
    }
    configJson.compilerOptions = Object.assign(getDefaultCompilerOptions(), configJson.compilerOptions);
    // If the user supplied exclude, let's use theirs
    (_c = configJson.exclude) !== null && _c !== void 0 ? _c : (configJson.exclude = getDefaultExclude());
    // Delete include so that .astro files don't get mistakenly excluded by the user
    delete configJson.include;
    // Everything here will always, unconditionally, be in the resulting config, not the opposite, tricky
    const existingCompilerOptions = {
        // Setting strict to true for .astro files leads to a lot of unrelated errors (see language-tools#91) so we force it off for .astro files
        strict: false,
        jsx: ts.JsxEmit.Preserve,
        module: ts.ModuleKind.ESNext,
        target: ts.ScriptTarget.ESNext,
    };
    const project = ts.parseJsonConfigFileContent(configJson, parseConfigHost, workspaceRoot, existingCompilerOptions, (0, path_1.basename)(tsconfigPath), undefined, [
        { extension: '.vue', isMixedContent: true, scriptKind: ts.ScriptKind.Deferred },
        { extension: '.svelte', isMixedContent: true, scriptKind: ts.ScriptKind.Deferred },
        { extension: '.astro', isMixedContent: true, scriptKind: ts.ScriptKind.Deferred },
    ]);
    let projectVersion = 0;
    const snapshotManager = new SnapshotManager_1.SnapshotManager(project.fileNames, {
        exclude: ['node_modules', 'dist'],
        include: ['src'],
    }, workspaceRoot || process.cwd());
    const astroModuleLoader = (0, module_loader_1.createAstroModuleLoader)(getScriptSnapshot, {});
    const host = {
        getNewLine: () => ts.sys.newLine,
        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,
        readFile: astroModuleLoader.readFile,
        writeFile: astroModuleLoader.writeFile,
        fileExists: astroModuleLoader.fileExists,
        directoryExists: astroModuleLoader.directoryExists,
        getDirectories: astroModuleLoader.getDirectories,
        readDirectory: astroModuleLoader.readDirectory,
        realpath: astroModuleLoader.realpath,
        getCompilationSettings: () => project.options,
        getCurrentDirectory: () => workspaceRoot,
        getDefaultLibFileName: () => ts.getDefaultLibFilePath(project.options),
        getProjectVersion: () => projectVersion.toString(),
        getScriptFileNames: () => Array.from(new Set([...snapshotManager.getFileNames(), ...snapshotManager.getProjectFileNames()])),
        getScriptSnapshot,
        getScriptVersion: (fileName) => {
            let snapshotVersion = getScriptSnapshot(fileName).version.toString();
            return snapshotVersion;
        },
    };
    const languageService = ts.createLanguageService(host);
    const languageServiceProxy = new Proxy(languageService, {
        get(target, prop) {
            return Reflect.get(target, prop);
        },
    });
    return {
        tsconfigPath,
        snapshotManager,
        getService: () => languageServiceProxy,
        updateDocument,
        deleteDocument,
    };
    function onProjectUpdated() {
        projectVersion++;
    }
    function deleteDocument(filePath) {
        snapshotManager.delete(filePath);
    }
    function updateDocument(documentOrFilePath) {
        const filePath = (0, utils_1.ensureRealAstroFilePath)(typeof documentOrFilePath === 'string' ? documentOrFilePath : documentOrFilePath.getFilePath() || '');
        const document = typeof documentOrFilePath === 'string' ? undefined : documentOrFilePath;
        if (!filePath) {
            throw new Error(`Unable to find document`);
        }
        const previousSnapshot = snapshotManager.get(filePath);
        if (document && (previousSnapshot === null || previousSnapshot === void 0 ? void 0 : previousSnapshot.version.toString()) === `${document.version}`) {
            return previousSnapshot;
        }
        const currentText = document ? document.getText() : null;
        const snapshot = (0, DocumentSnapshot_1.createDocumentSnapshot)(filePath, currentText, docContext.createDocument);
        snapshotManager.set(filePath, snapshot);
        onProjectUpdated();
        return snapshot;
    }
    function getScriptSnapshot(fileName) {
        fileName = (0, utils_1.ensureRealAstroFilePath)(fileName);
        let doc = snapshotManager.get(fileName);
        if (doc) {
            return doc;
        }
        doc = (0, DocumentSnapshot_1.createDocumentSnapshot)(fileName, null, docContext.createDocument);
        snapshotManager.set(fileName, doc);
        return doc;
    }
}
function getDefaultCompilerOptions() {
    return {
        maxNodeModuleJsDepth: 2,
        allowSyntheticDefaultImports: true,
        allowJs: true,
        // By providing vite/client here, our users get proper typing on import.meta in .astro files
        types: ["vite/client"],
    };
}
function getDefaultExclude() {
    return ['dist', 'node_modules'];
}
