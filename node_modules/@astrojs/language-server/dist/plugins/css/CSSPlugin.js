"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CSSPlugin = void 0;
const vscode_emmet_helper_1 = require("vscode-emmet-helper");
const vscode_languageserver_1 = require("vscode-languageserver");
const utils_1 = require("../../core/documents/utils");
const CSSDocument_1 = require("./CSSDocument");
const service_1 = require("./service");
const StyleAttributeDocument_1 = require("./StyleAttributeDocument");
const documents_1 = require("../../core/documents");
const parseHtml_1 = require("../../core/documents/parseHtml");
const getIdClassCompletion_1 = require("./features/getIdClassCompletion");
class CSSPlugin {
    constructor(docManager, configManager) {
        this.documents = new WeakMap();
        this.triggerCharacters = new Set(['.', ':', '-', '/']);
        this.pluginName = 'CSS';
        this.docManager = docManager;
        this.configManager = configManager;
        this.docManager.on('documentChange', (document) => {
            this.documents.set(document, new CSSDocument_1.CSSDocument(document));
        });
    }
    getCompletions(document, position, completionContext) {
        const triggerCharacter = completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerCharacter;
        const triggerKind = completionContext === null || completionContext === void 0 ? void 0 : completionContext.triggerKind;
        const isCustomTriggerCharacter = triggerKind === vscode_languageserver_1.CompletionTriggerKind.TriggerCharacter;
        if (isCustomTriggerCharacter && triggerCharacter && !this.triggerCharacters.has(triggerCharacter)) {
            return null;
        }
        if (this.isInsideFrontmatter(document, position)) {
            return null;
        }
        const cssDocument = this.getCSSDoc(document);
        if (cssDocument.isInGenerated(position)) {
            return this.getCompletionsInternal(document, position, cssDocument);
        }
        const attributeContext = (0, parseHtml_1.getAttributeContextAtPosition)(document, position);
        if (!attributeContext) {
            return null;
        }
        if (this.inStyleAttributeWithoutInterpolation(attributeContext, document.getText())) {
            const [start, end] = attributeContext.valueRange;
            return this.getCompletionsInternal(document, position, new StyleAttributeDocument_1.StyleAttributeDocument(document, start, end));
        }
        else {
            return (0, getIdClassCompletion_1.getIdClassCompletion)(cssDocument, attributeContext);
        }
    }
    getCompletionsInternal(document, position, cssDocument) {
        if (isSASS(cssDocument)) {
            // the css language service does not support sass, still we can use
            // the emmet helper directly to at least get emmet completions
            return (0, vscode_emmet_helper_1.doComplete)(document, position, 'sass', this.configManager.getEmmetConfig());
        }
        const type = extractLanguage(cssDocument);
        const lang = (0, service_1.getLanguageService)(type);
        const emmetResults = {
            isIncomplete: true,
            items: [],
        };
        if (false /* this.configManager.getConfig().css.completions.emmet */) {
            lang.setCompletionParticipants([
                (0, vscode_emmet_helper_1.getEmmetCompletionParticipants)(cssDocument, cssDocument.getGeneratedPosition(position), (0, service_1.getLanguage)(type), this.configManager.getEmmetConfig(), emmetResults),
            ]);
        }
        const results = lang.doComplete(cssDocument, cssDocument.getGeneratedPosition(position), cssDocument.stylesheet);
        return vscode_languageserver_1.CompletionList.create([...(results ? results.items : []), ...emmetResults.items].map((completionItem) => (0, documents_1.mapCompletionItemToOriginal)(cssDocument, completionItem)), 
        // Emmet completions change on every keystroke, so they are never complete
        emmetResults.items.length > 0);
    }
    inStyleAttributeWithoutInterpolation(attrContext, text) {
        return attrContext.name === 'style' && !!attrContext.valueRange && !text.substring(attrContext.valueRange[0], attrContext.valueRange[1]).includes('{');
    }
    getCSSDoc(document) {
        let cssDoc = this.documents.get(document);
        if (!cssDoc || cssDoc.version < document.version) {
            cssDoc = new CSSDocument_1.CSSDocument(document);
            this.documents.set(document, cssDoc);
        }
        return cssDoc;
    }
    isInsideFrontmatter(document, position) {
        return (0, utils_1.isInsideFrontmatter)(document.getText(), document.offsetAt(position));
    }
}
exports.CSSPlugin = CSSPlugin;
function isSASS(document) {
    switch (extractLanguage(document)) {
        case 'sass':
            return true;
        default:
            return false;
    }
}
function extractLanguage(document) {
    const lang = document.languageId;
    return lang.replace(/^text\//, '');
}
